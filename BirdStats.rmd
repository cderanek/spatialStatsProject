---
title: "Bird_Project"
author: "Alicia Pentico"
date: "April 21, 2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r}
library(rgdal) # Provides links to the 'Geospatial' Data Abstraction Library ('GDAL') and access to projection/transformation operations from the 'PROJ.4' library.
library(sp) # Classes and methods for spatial data
library(spdep) # for modeling of spatial dependencies
library(maptools) # provides various mapping functions
library(RANN) # for nearest neighbor calculations
library(gstat)
```

### READING IN DATA
```{r}
captureBirds<-read.csv("balbina_understory_birds_captures.csv", header = TRUE)
birdInfo<-read.csv("balbina_understory_birds_taxonomy_traits.csv", header = TRUE)
environment<-read.csv("balbina_environmental_variables.csv", header = TRUE)
str(captureBirds)
```

###DATA FORMATTING
```{r}
#str(captureBirds)
noRecaptures <- subset(captureBirds, captureBirds$new.individual == "yes")

perLocation<- as.data.frame(table(noRecaptures$site))
perLocation$longitude<- environment$longitude.WGS84
perLocation$latitude<- environment$latitude.WGS84
perLocation$coverage<- environment$forest.cover.200

names(perLocation)<- c("site", "abundance", "longitude", "latitude","coverage")
str(perLocation)

# create vectors to hold species richness and names to later add as cols to perLocation
speciesRichnessBySite=vector('integer',length=length(perLocation$site))
speciesNamesBySite=vector('list',length=length(perLocation$site))

# create matrix to pass into species accumulation curve formula
allSpeciesNames = sort(unique(noRecaptures$species),return=TRUE)
specAccumDF <- data.frame(matrix(ncol = length(allSpeciesNames), nrow = length(perLocation$site)))
colnames(specAccumDF) <- allSpeciesNames
row.names(specAccumDF) <- perLocation$site

# get number of species at each site, list of species at each site
for (i in 1:length(perLocation$site)){
  siteName = perLocation$site[i]
  
  # operations to get T/F list of species at site
  set<-subset(noRecaptures, site == siteName)
  byLocation <- as.data.frame(table(set$species))
  speciesFoundatSite = (byLocation$Freq != 0)
  
  # add speciesRichness to vector
  speciesRichnessBySite[i] = sum(speciesFoundatSite)
  speciesNamesBySite[i] = list(as.character(byLocation$Var1[speciesFoundatSite]))
  
  # update specAccumDF
  byLocation[order(byLocation$Var1),] #makes sure things get inputted in correct order
  specAccumDF[i,] = byLocation$Freq
  
}

# add species richness and names to perLocation
perLocation$speciesRichness<- speciesRichnessBySite
perLocation$speciesNamesL<- speciesNamesBySite
```



###IDW ABUNDANCE, SPECIES RICHNESS

Creating a spatial points data frame
```{r}
### Converting data into a spatial points data frame
perLocation.spdf <- perLocation
coordinates(perLocation.spdf) <- ~ longitude + latitude ##(remember that in R longitude is assigned to x-axis and latitude to y-axis)
class(perLocation.spdf)
bbox(perLocation.spdf)
```

#Abundance 
Data Transformations
```{r}
### Examining normality of the abundance and selected Sqrt transformation
hist(perLocation.spdf@data$abundance) ## Note abundance is not normally distributed. Should transform dataset
qqnorm(perLocation.spdf@data$abundance)
qqline(perLocation.spdf@data$abundance)

hist(log(perLocation.spdf@data$abundance)) ## Log Transformation --> still not great
qqnorm(log(perLocation.spdf@data$abundance))
qqline(log(perLocation.spdf@data$abundance))

hist((sqrt(perLocation.spdf@data$abundance))) ## Sqrt Transformation ---> Transformation I am using
qqnorm((sqrt(perLocation.spdf@data$abundance)))
qqline((sqrt(perLocation.spdf@data$abundance)))

hist(1/(perLocation.spdf@data$abundance)) ## 1/y Transformation --> real bad
qqnorm(1/(perLocation.spdf@data$abundance)) 
qqline(1/(perLocation.spdf@data$abundance))

perLocation.spdf@data$transformedAbundance <- sqrt(perLocation.spdf@data$abundance)
```
Inverse Distance Weighted

```{r}
x.range <- as.numeric(c(-60, -59.15671))  # min/max longitude of the interpolation area
y.range <- as.numeric(c(-1.97378, -1.32884))  # min/max latitude of the interpolation area


grd <- expand.grid(x = seq(from = x.range[1], to = x.range[2], by = 0.001), y = seq(from = y.range[1], 
    to = y.range[2], by = 0.001))  # expand points to grid
coordinates(grd) <- ~x + y
gridded(grd) <- TRUE
plot(grd, cex = 1.5, col = "grey") 
plot(perLocation.spdf, add=TRUE, pch = 1, col = "red", cex = 1)


idw <- gstat::idw(formula = perLocation.spdf@data$transformedAbundance ~ 1, locations = perLocation.spdf, newdata = grd, idp=2.0) 
plot(idw)

```


#Species Richness 
Transformation
```{r}
### Examining normality of the abundance and selected Sqrt transformation
hist(perLocation.spdf@data$speciesRichness) ## Note abundance is not normally distributed. Should transform dataset
qqnorm(perLocation.spdf$abundance)

hist(log(perLocation.spdf$abundance)) ## Log Transformation --> still not great
qqnorm(log(perLocation.spdf$abundance)) 

hist(sqrt(perLocation.spdf$abundance)) ## Sqrt Transformation ---> Transformation I am using
qqnorm(sqrt(perLocation.spdf$abundance)) 

hist(1/(perLocation.spdf$abundance)) ## 1/y Transformation --> real bad
qqnorm(1/(perLocation.spdf$abundance)) 

perLocation.spdf@data$transformedRichness <- sqrt(perLocation.spdf@data$speciesRichness)
```


IDW
```{r}
idw <- gstat::idw(formula = perLocation.spdf@data$transformedRichness ~ 1, locations = perLocation.spdf, newdata = grd, idp=2.0) 
plot(idw)

```


###EXAMPLE FOR SCPEC ACCUM
```{r}
library(vegan)
#data("BCI")
# learned that for specaccum function, we pass in dataframe whose cols are species names and rows are incidents, each cell has the count of species@thatincidence

```


###DIET BY LOCATION - MAKE KRIGING BY DIETS, THINK OF SOME ANALYSIS USING MORE DETAILED DIET NUMBERS
```{r}


```
