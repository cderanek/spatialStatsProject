---
title: "Bird_Project"
author: "Alicia Pentico"
date: "April 21, 2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


Remember that diet is small proxy. Some birds could eat more than others
Moran's I to tell if birds are clustered. 
Diversity analysis?
Add jackknife Analysis
Spatial regression model could have seasonality as factors.

```{r}
library(rgdal) # Provides links to the 'Geospatial' Data Abstraction Library ('GDAL') and access to projection/transformation operations from the 'PROJ.4' library.
library(sp) # Classes and methods for spatial data
library(spdep) # for modeling of spatial dependencies
library(maptools) # provides various mapping functions
library(RANN) # for nearest neighbor calculations
library(gstat)
library(base)

```

### READING IN DATA
```{r}
captureBirds<-read.csv("balbina_understory_birds_captures.csv", header = TRUE)
birdInfo<-read.csv("balbina_understory_birds_taxonomy_traits.csv", header = TRUE)
environment<-read.csv("balbina_environmental_variables.csv", header = TRUE)
```

###DATA FORMATTING
```{r}
noRecaptures <- subset(captureBirds, captureBirds$new.individual == "yes")

perLocation<- as.data.frame(table(noRecaptures$site))
perLocation$longitude<- environment$longitude.WGS84
perLocation$latitude<- environment$latitude.WGS84
perLocation$coverage<- environment$forest.cover.200

names(perLocation)<- c("site", "abundance", "longitude", "latitude","coverage")
str(perLocation)

# create vectors to hold species richness and names to later add as cols to perLocation
speciesRichnessBySite=vector('integer',length=length(perLocation$site))
speciesNamesBySite=vector('list',length=length(perLocation$site))

# get number of species at each site, list of species at each site
# TODO FORMAT SUCH THAT WE MAKE READY FOR SPEC ACCUM - CARISSA TASK
for (i in 1:length(perLocation$site)){
  siteName = perLocation$site[i]
  
  # operations to get T/F list of species at site
  set<-subset(noRecaptures, site == siteName)
  byLocation <- as.data.frame(table(set$species))
  speciesFoundatSite = (byLocation$Freq != 0)
  
  # add speciesRichness to vector
  speciesRichnessBySite[i] = sum(speciesFoundatSite)
  
  speciesFreqs <- list()
  for (j in 1:length(byLocation$Var1)){
    if(byLocation$Freq[j] != 0){
      speciesFreqs[[as.character(byLocation$Var1[j])]] = byLocation$Freq[j]
    }
  }
  speciesNamesBySite[[i]] = speciesFreqs
  
}

# add species richness and names to perLocation
perLocation$speciesRichness<- speciesRichnessBySite
perLocation$speciesNamesL<- speciesNamesBySite
```



###IDW ABUNDANCE, SPECIES RICHNESS - TODO ALICIA

Creating a spatial points data frame
```{r}
### Converting data into a spatial points data frame
perLocation.spdf <- perLocation
coordinates(perLocation.spdf) <- ~ longitude + latitude ##(remember that in R longitude is assigned to x-axis and latitude to y-axis)
class(perLocation.spdf)
bbox(perLocation.spdf)
```

#Abundance 
Data Transformations
```{r}
### Examining normality of the abundance and selected Sqrt transformation
hist(perLocation.spdf@data$abundance) ## Note abundance is not normally distributed. Should transform dataset
qqnorm(perLocation.spdf@data$abundance)
qqline(perLocation.spdf@data$abundance)

hist(log(perLocation.spdf@data$abundance)) ## Log Transformation --> still not great
qqnorm(log(perLocation.spdf@data$abundance))
qqline(log(perLocation.spdf@data$abundance))

hist((sqrt(perLocation.spdf@data$abundance))) ## Sqrt Transformation ---> Transformation I am using
qqnorm((sqrt(perLocation.spdf@data$abundance)))
qqline((sqrt(perLocation.spdf@data$abundance)))

hist(1/(perLocation.spdf@data$abundance)) ## 1/y Transformation --> real bad
qqnorm(1/(perLocation.spdf@data$abundance)) 
qqline(1/(perLocation.spdf@data$abundance))

perLocation.spdf@data$transformedAbundance <- sqrt(perLocation.spdf@data$abundance)
```
Inverse Distance Weighted

```{r}
x.range <- as.numeric(c(-60, -59.15671))  # min/max longitude of the interpolation area
y.range <- as.numeric(c(-1.97378, -1.32884))  # min/max latitude of the interpolation area


grd <- expand.grid(x = seq(from = x.range[1], to = x.range[2], by = 0.001), y = seq(from = y.range[1], 
    to = y.range[2], by = 0.001))  # expand points to grid
coordinates(grd) <- ~x + y
gridded(grd) <- TRUE
plot(grd, cex = 1.5, col = "grey") 
plot(perLocation.spdf, add=TRUE, pch = 1, col = "red", cex = 1)


idw <- gstat::idw(formula = perLocation.spdf@data$transformedAbundance ~ 1, locations = perLocation.spdf, newdata = grd, idp=2.0) 
plot(idw)

```


#Species Richness 
Transformation
```{r}
### Examining normality of the abundance and selected Sqrt transformation
hist(perLocation.spdf@data$speciesRichness) ## Note abundance is not normally distributed. Should transform dataset
qqnorm(perLocation.spdf$abundance)

hist(log(perLocation.spdf$abundance)) ## Log Transformation --> still not great
qqnorm(log(perLocation.spdf$abundance)) 

hist(sqrt(perLocation.spdf$abundance)) ## Sqrt Transformation ---> Transformation I am using
qqnorm(sqrt(perLocation.spdf$abundance)) 

hist(1/(perLocation.spdf$abundance)) ## 1/y Transformation --> real bad
qqnorm(1/(perLocation.spdf$abundance)) 

perLocation.spdf@data$transformedRichness <- sqrt(perLocation.spdf@data$speciesRichness)
```


IDW
```{r}
idw <- gstat::idw(formula = perLocation.spdf@data$transformedRichness ~ 1, locations = perLocation.spdf, newdata = grd, idp=2.0) 
plot(idw)

```


###DIET ANALYSES

Data Wrangling
```{r}
dietL <- c("diet.inv", "diet.vend", "diet.vect", "diet.vfish","diet.vunk","diet.fruit","diet.nect","diet.seed","diet.planto")
dietByRegion <- matrix(1:342, nrow = 38, ncol = 9)
colnames(dietByRegion) <- dietL

for (i in 1:38){ #num rows is each location
  for (j in 1:9){ #num cols is each diet type
    
    food = birdInfo[,dietL[j]] #Vector of particular Diet
    
    sumDiet <- 0
    individualCount <- 0
    
    birdsAtSite <- perLocation$speciesNamesL[[i]]
    birdNames = names(birdsAtSite)
    
    for (k in 1:length(birdNames)){
      bird = birdNames[k]
      numBirds = birdsAtSite[[bird]]
      
      individualCount <- individualCount+numBirds
      
      birdLocation = match(bird, birdInfo$birdlife.2016)
      if (is.na(birdLocation)){
        birdLocation = match(bird, birdInfo$cbro.2015)
      }
      else if (is.na(birdLocation)){
        birdLocation = match(bird, birdInfo$wilman.2014)
      }
      foodEaten = food[birdLocation] #Perent of Diet for that particular bird

      sumDiet <- sumDiet + (numBirds * foodEaten)
      
    }
    
    dietByRegion[i,j] = sumDiet/ (100*individualCount)
  }
}

```


###Species Accumulation
```{r}
#str(captureBirds)
noRecaptures <- subset(captureBirds, captureBirds$new.individual == "yes")

perLocation<- as.data.frame(table(noRecaptures$site))
perLocation$longitude<- environment$longitude.WGS84
perLocation$latitude<- environment$latitude.WGS84
perLocation$coverage<- environment$forest.cover.200

names(perLocation)<- c("site", "abundance", "longitude", "latitude","coverage")
str(perLocation)

# create vectors to hold species richness and names to later add as cols to perLocation
speciesRichnessBySite=vector('integer',length=length(perLocation$site))
speciesNamesBySite=vector('list',length=length(perLocation$site))

# create matrix to pass into species accumulation curve formula
allSpeciesNames = sort(unique(noRecaptures$species),return=TRUE)
specAccumDF <- data.frame(matrix(ncol = length(allSpeciesNames), nrow = length(perLocation$site)))
colnames(specAccumDF) <- allSpeciesNames
row.names(specAccumDF) <- perLocation$site

# get number of species at each site, list of species at each site
for (i in 1:length(perLocation$site)){
  siteName = perLocation$site[i]
  
  # operations to get T/F list of species at site
  set<-subset(noRecaptures, site == siteName)
  byLocation <- as.data.frame(table(set$species))
  speciesFoundatSite = (byLocation$Freq != 0)
  
  # add speciesRichness to vector
  speciesRichnessBySite[i] = sum(speciesFoundatSite)
  speciesNamesBySite[i] = list(as.character(byLocation$Var1[speciesFoundatSite]))
  
  # update specAccumDF
  byLocation[order(byLocation$Var1),] #makes sure things get inputted in correct order
  specAccumDF[i,] = byLocation$Freq
  
}

# add species richness and names to perLocation
perLocation$speciesRichness<- speciesRichnessBySite
perLocation$speciesNamesL<- speciesNamesBySite
```

###BASEMAPS
```{r}
library(leaflet)
medLong = median(perLocation.spdf@coords[,1])
medLat = median(perLocation.spdf@coords[,2])

abundanceVals=sort(perLocation.spdf@data$abundance)
lowerQuarterAbundance = abundanceVals[floor(length(abundanceVals)/4)]
upperQuarterAbundance = abundanceVals[length(abundanceVals)-floor(length(abundanceVals)/4)]

getColor <- function(df) {
  sapply(df$abundance, function(abundance) {
  if(abundance <= lowerQuarterAbundance) {
    "red"
  } else if(abundance <= upperQuarterAbundance) {
    "orange"
  } else {
    "green"
  } })
}

icons <- awesomeIcons(
  icon = 'ios-close',
  iconColor = 'black',
  library = 'ion',
  markerColor = getColor(perLocation.spdf@data)
)


# draw map
m = leaflet(perLocation.spdf) %>% setView(lng = medLong, lat = medLat, zoom = 10)
m %>% addTiles() %>% addAwesomeMarkers(icon=icons, label = ~as.character(abundance), popup=~as.character(site))

```
